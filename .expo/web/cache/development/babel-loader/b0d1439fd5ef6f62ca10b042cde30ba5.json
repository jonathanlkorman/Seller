{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { Platform } from '@unimodules/core';\nimport { PermissionStatus } from 'unimodules-permissions-interface';\nimport ExpoLocation from \"./ExpoLocation\";\nimport { LocationAccuracy, LocationActivityType, LocationGeofencingEventType, LocationGeofencingRegionState } from \"./Location.types\";\nimport { LocationEventEmitter } from \"./LocationEventEmitter\";\nimport { setGoogleApiKey, googleGeocodeAsync, googleReverseGeocodeAsync } from \"./LocationGoogleGeocoding\";\nimport { LocationSubscriber, HeadingSubscriber, _getCurrentWatchId } from \"./LocationSubscribers\";\nexport function getProviderStatusAsync() {\n  return _regeneratorRuntime.async(function getProviderStatusAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          return _context.abrupt(\"return\", ExpoLocation.getProviderStatusAsync());\n\n        case 1:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function enableNetworkProviderAsync() {\n  return _regeneratorRuntime.async(function enableNetworkProviderAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          if (!(Platform.OS === 'android')) {\n            _context2.next = 2;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", ExpoLocation.enableNetworkProviderAsync());\n\n        case 2:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getCurrentPositionAsync() {\n  var options,\n      _args3 = arguments;\n  return _regeneratorRuntime.async(function getCurrentPositionAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};\n          return _context3.abrupt(\"return\", ExpoLocation.getCurrentPositionAsync(options));\n\n        case 2:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getLastKnownPositionAsync() {\n  var options,\n      _args4 = arguments;\n  return _regeneratorRuntime.async(function getLastKnownPositionAsync$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          options = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};\n          return _context4.abrupt(\"return\", ExpoLocation.getLastKnownPositionAsync(options));\n\n        case 2:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function watchPositionAsync(options, callback) {\n  var watchId;\n  return _regeneratorRuntime.async(function watchPositionAsync$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          watchId = LocationSubscriber.registerCallback(callback);\n          _context5.next = 3;\n          return _regeneratorRuntime.awrap(ExpoLocation.watchPositionImplAsync(watchId, options));\n\n        case 3:\n          return _context5.abrupt(\"return\", {\n            remove: function remove() {\n              LocationSubscriber.unregisterCallback(watchId);\n            }\n          });\n\n        case 4:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getHeadingAsync() {\n  return _regeneratorRuntime.async(function getHeadingAsync$(_context7) {\n    while (1) {\n      switch (_context7.prev = _context7.next) {\n        case 0:\n          return _context7.abrupt(\"return\", new Promise(function _callee(resolve) {\n            var tries, subscription;\n            return _regeneratorRuntime.async(function _callee$(_context6) {\n              while (1) {\n                switch (_context6.prev = _context6.next) {\n                  case 0:\n                    tries = 0;\n                    _context6.next = 3;\n                    return _regeneratorRuntime.awrap(watchHeadingAsync(function (heading) {\n                      if (heading.accuracy > 1 || tries > 5) {\n                        subscription.remove();\n                        resolve(heading);\n                      } else {\n                        tries += 1;\n                      }\n                    }));\n\n                  case 3:\n                    subscription = _context6.sent;\n\n                  case 4:\n                  case \"end\":\n                    return _context6.stop();\n                }\n              }\n            }, null, null, null, Promise);\n          }));\n\n        case 1:\n        case \"end\":\n          return _context7.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function watchHeadingAsync(callback) {\n  var watchId;\n  return _regeneratorRuntime.async(function watchHeadingAsync$(_context8) {\n    while (1) {\n      switch (_context8.prev = _context8.next) {\n        case 0:\n          watchId = HeadingSubscriber.registerCallback(callback);\n          _context8.next = 3;\n          return _regeneratorRuntime.awrap(ExpoLocation.watchDeviceHeading(watchId));\n\n        case 3:\n          return _context8.abrupt(\"return\", {\n            remove: function remove() {\n              HeadingSubscriber.unregisterCallback(watchId);\n            }\n          });\n\n        case 4:\n        case \"end\":\n          return _context8.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function geocodeAsync(address, options) {\n  return _regeneratorRuntime.async(function geocodeAsync$(_context9) {\n    while (1) {\n      switch (_context9.prev = _context9.next) {\n        case 0:\n          if (!(typeof address !== 'string')) {\n            _context9.next = 2;\n            break;\n          }\n\n          throw new TypeError(\"Address to geocode must be a string. Got \" + address + \" instead.\");\n\n        case 2:\n          if (!(options != null && options.useGoogleMaps || Platform.OS === 'web')) {\n            _context9.next = 6;\n            break;\n          }\n\n          _context9.next = 5;\n          return _regeneratorRuntime.awrap(googleGeocodeAsync(address));\n\n        case 5:\n          return _context9.abrupt(\"return\", _context9.sent);\n\n        case 6:\n          _context9.next = 8;\n          return _regeneratorRuntime.awrap(ExpoLocation.geocodeAsync(address));\n\n        case 8:\n          return _context9.abrupt(\"return\", _context9.sent);\n\n        case 9:\n        case \"end\":\n          return _context9.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function reverseGeocodeAsync(location, options) {\n  return _regeneratorRuntime.async(function reverseGeocodeAsync$(_context10) {\n    while (1) {\n      switch (_context10.prev = _context10.next) {\n        case 0:\n          if (!(typeof location.latitude !== 'number' || typeof location.longitude !== 'number')) {\n            _context10.next = 2;\n            break;\n          }\n\n          throw new TypeError('Location to reverse-geocode must be an object with number properties `latitude` and `longitude`.');\n\n        case 2:\n          if (!(options != null && options.useGoogleMaps || Platform.OS === 'web')) {\n            _context10.next = 6;\n            break;\n          }\n\n          _context10.next = 5;\n          return _regeneratorRuntime.awrap(googleReverseGeocodeAsync(location));\n\n        case 5:\n          return _context10.abrupt(\"return\", _context10.sent);\n\n        case 6:\n          _context10.next = 8;\n          return _regeneratorRuntime.awrap(ExpoLocation.reverseGeocodeAsync(location));\n\n        case 8:\n          return _context10.abrupt(\"return\", _context10.sent);\n\n        case 9:\n        case \"end\":\n          return _context10.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getPermissionsAsync() {\n  return _regeneratorRuntime.async(function getPermissionsAsync$(_context11) {\n    while (1) {\n      switch (_context11.prev = _context11.next) {\n        case 0:\n          _context11.next = 2;\n          return _regeneratorRuntime.awrap(ExpoLocation.getPermissionsAsync());\n\n        case 2:\n          return _context11.abrupt(\"return\", _context11.sent);\n\n        case 3:\n        case \"end\":\n          return _context11.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function requestPermissionsAsync() {\n  return _regeneratorRuntime.async(function requestPermissionsAsync$(_context12) {\n    while (1) {\n      switch (_context12.prev = _context12.next) {\n        case 0:\n          _context12.next = 2;\n          return _regeneratorRuntime.awrap(ExpoLocation.requestPermissionsAsync());\n\n        case 2:\n          return _context12.abrupt(\"return\", _context12.sent);\n\n        case 3:\n        case \"end\":\n          return _context12.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function hasServicesEnabledAsync() {\n  return _regeneratorRuntime.async(function hasServicesEnabledAsync$(_context13) {\n    while (1) {\n      switch (_context13.prev = _context13.next) {\n        case 0:\n          _context13.next = 2;\n          return _regeneratorRuntime.awrap(ExpoLocation.hasServicesEnabledAsync());\n\n        case 2:\n          return _context13.abrupt(\"return\", _context13.sent);\n\n        case 3:\n        case \"end\":\n          return _context13.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction _validateTaskName(taskName) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new Error(\"`taskName` must be a non-empty string. Got \" + taskName + \" instead.\");\n  }\n}\n\nexport function isBackgroundLocationAvailableAsync() {\n  var providerStatus;\n  return _regeneratorRuntime.async(function isBackgroundLocationAvailableAsync$(_context14) {\n    while (1) {\n      switch (_context14.prev = _context14.next) {\n        case 0:\n          _context14.next = 2;\n          return _regeneratorRuntime.awrap(getProviderStatusAsync());\n\n        case 2:\n          providerStatus = _context14.sent;\n          return _context14.abrupt(\"return\", providerStatus.backgroundModeEnabled);\n\n        case 4:\n        case \"end\":\n          return _context14.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function startLocationUpdatesAsync(taskName) {\n  var options,\n      _args15 = arguments;\n  return _regeneratorRuntime.async(function startLocationUpdatesAsync$(_context15) {\n    while (1) {\n      switch (_context15.prev = _context15.next) {\n        case 0:\n          options = _args15.length > 1 && _args15[1] !== undefined ? _args15[1] : {\n            accuracy: LocationAccuracy.Balanced\n          };\n\n          _validateTaskName(taskName);\n\n          _context15.next = 4;\n          return _regeneratorRuntime.awrap(ExpoLocation.startLocationUpdatesAsync(taskName, options));\n\n        case 4:\n        case \"end\":\n          return _context15.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function stopLocationUpdatesAsync(taskName) {\n  return _regeneratorRuntime.async(function stopLocationUpdatesAsync$(_context16) {\n    while (1) {\n      switch (_context16.prev = _context16.next) {\n        case 0:\n          _validateTaskName(taskName);\n\n          _context16.next = 3;\n          return _regeneratorRuntime.awrap(ExpoLocation.stopLocationUpdatesAsync(taskName));\n\n        case 3:\n        case \"end\":\n          return _context16.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function hasStartedLocationUpdatesAsync(taskName) {\n  return _regeneratorRuntime.async(function hasStartedLocationUpdatesAsync$(_context17) {\n    while (1) {\n      switch (_context17.prev = _context17.next) {\n        case 0:\n          _validateTaskName(taskName);\n\n          return _context17.abrupt(\"return\", ExpoLocation.hasStartedLocationUpdatesAsync(taskName));\n\n        case 2:\n        case \"end\":\n          return _context17.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction _validateRegions(regions) {\n  if (!regions || regions.length === 0) {\n    throw new Error('Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions');\n  }\n\n  for (var _iterator = _createForOfIteratorHelperLoose(regions), _step; !(_step = _iterator()).done;) {\n    var region = _step.value;\n\n    if (typeof region.latitude !== 'number') {\n      throw new TypeError(\"Region's latitude must be a number. Got '\" + region.latitude + \"' instead.\");\n    }\n\n    if (typeof region.longitude !== 'number') {\n      throw new TypeError(\"Region's longitude must be a number. Got '\" + region.longitude + \"' instead.\");\n    }\n\n    if (typeof region.radius !== 'number') {\n      throw new TypeError(\"Region's radius must be a number. Got '\" + region.radius + \"' instead.\");\n    }\n  }\n}\n\nexport function startGeofencingAsync(taskName) {\n  var regions,\n      _args18 = arguments;\n  return _regeneratorRuntime.async(function startGeofencingAsync$(_context18) {\n    while (1) {\n      switch (_context18.prev = _context18.next) {\n        case 0:\n          regions = _args18.length > 1 && _args18[1] !== undefined ? _args18[1] : [];\n\n          _validateTaskName(taskName);\n\n          _validateRegions(regions);\n\n          _context18.next = 5;\n          return _regeneratorRuntime.awrap(ExpoLocation.startGeofencingAsync(taskName, {\n            regions: regions\n          }));\n\n        case 5:\n        case \"end\":\n          return _context18.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function stopGeofencingAsync(taskName) {\n  return _regeneratorRuntime.async(function stopGeofencingAsync$(_context19) {\n    while (1) {\n      switch (_context19.prev = _context19.next) {\n        case 0:\n          _validateTaskName(taskName);\n\n          _context19.next = 3;\n          return _regeneratorRuntime.awrap(ExpoLocation.stopGeofencingAsync(taskName));\n\n        case 3:\n        case \"end\":\n          return _context19.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function hasStartedGeofencingAsync(taskName) {\n  return _regeneratorRuntime.async(function hasStartedGeofencingAsync$(_context20) {\n    while (1) {\n      switch (_context20.prev = _context20.next) {\n        case 0:\n          _validateTaskName(taskName);\n\n          return _context20.abrupt(\"return\", ExpoLocation.hasStartedGeofencingAsync(taskName));\n\n        case 2:\n        case \"end\":\n          return _context20.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function setApiKey(apiKey) {\n  console.warn(\"Location's method `setApiKey` is deprecated in favor of `setGoogleApiKey`.\");\n  setGoogleApiKey(apiKey);\n}\nexport { LocationEventEmitter as EventEmitter, _getCurrentWatchId };\nexport { LocationAccuracy as Accuracy, LocationActivityType as ActivityType, LocationGeofencingEventType as GeofencingEventType, LocationGeofencingRegionState as GeofencingRegionState, PermissionStatus, setGoogleApiKey };\nexport { installWebGeolocationPolyfill } from \"./GeolocationPolyfill\";\nexport * from \"./Location.types\";","map":{"version":3,"sources":["../src/Location.ts"],"names":[],"mappings":";;;;;;;;AAAA,SAAS,QAAT,QAAyB,kBAAzB;AACA,SAAS,gBAAT,QAAiC,kCAAjC;AAEA,OAAO,YAAP;AACA,SACE,gBADF,EAeE,oBAfF,EAgBE,2BAhBF,EAiBE,6BAjBF;AAoBA,SAAS,oBAAT;AACA,SACE,eADF,EAEE,kBAFF,EAGE,yBAHF;AAKA,SAAS,kBAAT,EAA6B,iBAA7B,EAAgD,kBAAhD;AAEA,OAAO,SAAe,sBAAf;AAAA;AAAA;AAAA;AAAA;AAAA,2CACE,YAAY,CAAC,sBAAb,EADF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIP,OAAO,SAAe,0BAAf;AAAA;AAAA;AAAA;AAAA;AAAA,gBAMD,QAAQ,CAAC,EAAT,KAAgB,SANf;AAAA;AAAA;AAAA;;AAAA,4CAOI,YAAY,CAAC,0BAAb,EAPJ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBP,OAAO,SAAe,uBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACL,UAAA,OADK,8DACsB,EADtB;AAAA,4CAGE,YAAY,CAAC,uBAAb,CAAqC,OAArC,CAHF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWP,OAAO,SAAe,yBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACL,UAAA,OADK,8DAC+B,EAD/B;AAAA,4CAGE,YAAY,CAAC,yBAAb,CAAuC,OAAvC,CAHF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUP,OAAO,SAAe,kBAAf,CAAkC,OAAlC,EAA4D,QAA5D;AAAA;AAAA;AAAA;AAAA;AAAA;AACC,UAAA,OADD,GACW,kBAAkB,CAAC,gBAAnB,CAAoC,QAApC,CADX;AAAA;AAAA,2CAEC,YAAY,CAAC,sBAAb,CAAoC,OAApC,EAA6C,OAA7C,CAFD;;AAAA;AAAA,4CAIE;AACL,YAAA,MADK,oBACC;AACJ,cAAA,kBAAkB,CAAC,kBAAnB,CAAsC,OAAtC;AACD;AAHI,WAJF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBP,OAAO,SAAe,eAAf;AAAA;AAAA;AAAA;AAAA;AAAA,4CACE,IAAI,OAAJ,CAAmC,iBAAM,OAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AACpC,oBAAA,KADoC,GAC5B,CAD4B;AAAA;AAAA,qDAGb,iBAAiB,CAAC,UAAA,OAAO,EAAG;AACrD,0BAAI,OAAO,CAAC,QAAR,GAAmB,CAAnB,IAAwB,KAAK,GAAG,CAApC,EAAuC;AACrC,wBAAA,YAAY,CAAC,MAAb;AACA,wBAAA,OAAO,CAAC,OAAD,CAAP;AACD,uBAHD,MAGO;AACL,wBAAA,KAAK,IAAI,CAAT;AACD;AACF,qBAP2C,CAHJ;;AAAA;AAGlC,oBAAA,YAHkC;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAnC,CADF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBP,OAAO,SAAe,iBAAf,CACL,QADK;AAAA;AAAA;AAAA;AAAA;AAAA;AAGC,UAAA,OAHD,GAGW,iBAAiB,CAAC,gBAAlB,CAAmC,QAAnC,CAHX;AAAA;AAAA,2CAIC,YAAY,CAAC,kBAAb,CAAgC,OAAhC,CAJD;;AAAA;AAAA,4CAME;AACL,YAAA,MADK,oBACC;AACJ,cAAA,iBAAiB,CAAC,kBAAlB,CAAqC,OAArC;AACD;AAHI,WANF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBP,OAAO,SAAe,YAAf,CACL,OADK,EAEL,OAFK;AAAA;AAAA;AAAA;AAAA;AAAA,gBAID,OAAO,OAAP,KAAmB,QAJlB;AAAA;AAAA;AAAA;;AAAA,gBAKG,IAAI,SAAJ,+CAA0D,OAA1D,eALH;;AAAA;AAAA,gBAOD,OAAO,QAAP,IAAA,OAAO,CAAE,aAAT,IAA0B,QAAQ,CAAC,EAAT,KAAgB,KAPzC;AAAA;AAAA;AAAA;;AAAA;AAAA,2CAQU,kBAAkB,CAAC,OAAD,CAR5B;;AAAA;AAAA;;AAAA;AAAA;AAAA,2CAUQ,YAAY,CAAC,YAAb,CAA0B,OAA1B,CAVR;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBP,OAAO,SAAe,mBAAf,CACL,QADK,EAEL,OAFK;AAAA;AAAA;AAAA;AAAA;AAAA,gBAID,OAAO,QAAQ,CAAC,QAAhB,KAA6B,QAA7B,IAAyC,OAAO,QAAQ,CAAC,SAAhB,KAA8B,QAJtE;AAAA;AAAA;AAAA;;AAAA,gBAKG,IAAI,SAAJ,CACJ,kGADI,CALH;;AAAA;AAAA,gBASD,OAAO,QAAP,IAAA,OAAO,CAAE,aAAT,IAA0B,QAAQ,CAAC,EAAT,KAAgB,KATzC;AAAA;AAAA;AAAA;;AAAA;AAAA,2CAUU,yBAAyB,CAAC,QAAD,CAVnC;;AAAA;AAAA;;AAAA;AAAA;AAAA,2CAYQ,YAAY,CAAC,mBAAb,CAAiC,QAAjC,CAZR;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkBP,OAAO,SAAe,mBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2CACQ,YAAY,CAAC,mBAAb,EADR;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOP,OAAO,SAAe,uBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2CACQ,YAAY,CAAC,uBAAb,EADR;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASP,OAAO,SAAe,uBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2CACQ,YAAY,CAAC,uBAAb,EADR;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMP,SAAS,iBAAT,CAA2B,QAA3B,EAA2C;AACzC,MAAI,CAAC,QAAD,IAAa,OAAO,QAAP,KAAoB,QAArC,EAA+C;AAC7C,UAAM,IAAI,KAAJ,iDAA0D,QAA1D,eAAN;AACD;AACF;;AAED,OAAO,SAAe,kCAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2CACwB,sBAAsB,EAD9C;;AAAA;AACC,UAAA,cADD;AAAA,6CAEE,cAAc,CAAC,qBAFjB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKP,OAAO,SAAe,yBAAf,CACL,QADK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEL,UAAA,OAFK,iEAE0B;AAAE,YAAA,QAAQ,EAAE,gBAAgB,CAAC;AAA7B,WAF1B;;AAIL,UAAA,iBAAiB,CAAC,QAAD,CAAjB;;AAJK;AAAA,2CAKC,YAAY,CAAC,yBAAb,CAAuC,QAAvC,EAAiD,OAAjD,CALD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQP,OAAO,SAAe,wBAAf,CAAwC,QAAxC;AAAA;AAAA;AAAA;AAAA;AACL,UAAA,iBAAiB,CAAC,QAAD,CAAjB;;AADK;AAAA,2CAEC,YAAY,CAAC,wBAAb,CAAsC,QAAtC,CAFD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKP,OAAO,SAAe,8BAAf,CAA8C,QAA9C;AAAA;AAAA;AAAA;AAAA;AACL,UAAA,iBAAiB,CAAC,QAAD,CAAjB;;AADK,6CAEE,YAAY,CAAC,8BAAb,CAA4C,QAA5C,CAFF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOP,SAAS,gBAAT,CAA0B,OAA1B,EAAmD;AACjD,MAAI,CAAC,OAAD,IAAY,OAAO,CAAC,MAAR,KAAmB,CAAnC,EAAsC;AACpC,UAAM,IAAI,KAAJ,CACJ,qGADI,CAAN;AAGD;;AACD,uDAAqB,OAArB,wCAA8B;AAAA,QAAnB,MAAmB;;AAC5B,QAAI,OAAO,MAAM,CAAC,QAAd,KAA2B,QAA/B,EAAyC;AACvC,YAAM,IAAI,SAAJ,+CAA0D,MAAM,CAAC,QAAjE,gBAAN;AACD;;AACD,QAAI,OAAO,MAAM,CAAC,SAAd,KAA4B,QAAhC,EAA0C;AACxC,YAAM,IAAI,SAAJ,gDACyC,MAAM,CAAC,SADhD,gBAAN;AAGD;;AACD,QAAI,OAAO,MAAM,CAAC,MAAd,KAAyB,QAA7B,EAAuC;AACrC,YAAM,IAAI,SAAJ,6CAAwD,MAAM,CAAC,MAA/D,gBAAN;AACD;AACF;AACF;;AAED,OAAO,SAAe,oBAAf,CACL,QADK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEL,UAAA,OAFK,iEAEuB,EAFvB;;AAIL,UAAA,iBAAiB,CAAC,QAAD,CAAjB;;AACA,UAAA,gBAAgB,CAAC,OAAD,CAAhB;;AALK;AAAA,2CAMC,YAAY,CAAC,oBAAb,CAAkC,QAAlC,EAA4C;AAAE,YAAA,OAAO,EAAP;AAAF,WAA5C,CAND;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASP,OAAO,SAAe,mBAAf,CAAmC,QAAnC;AAAA;AAAA;AAAA;AAAA;AACL,UAAA,iBAAiB,CAAC,QAAD,CAAjB;;AADK;AAAA,2CAEC,YAAY,CAAC,mBAAb,CAAiC,QAAjC,CAFD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKP,OAAO,SAAe,yBAAf,CAAyC,QAAzC;AAAA;AAAA;AAAA;AAAA;AACL,UAAA,iBAAiB,CAAC,QAAD,CAAjB;;AADK,6CAEE,YAAY,CAAC,yBAAb,CAAuC,QAAvC,CAFF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASP,OAAM,SAAU,SAAV,CAAoB,MAApB,EAAkC;AACtC,EAAA,OAAO,CAAC,IAAR,CAAa,4EAAb;AACA,EAAA,eAAe,CAAC,MAAD,CAAf;AACD;AAGD,SAAS,oBAAoB,IAAI,YAAjC,EAA+C,kBAA/C;AAGA,SACE,gBAAgB,IAAI,QADtB,EAEE,oBAAoB,IAAI,YAF1B,EAGE,2BAA2B,IAAI,mBAHjC,EAIE,6BAA6B,IAAI,qBAJnC,EAKE,gBALF,EAME,eANF;AASA,SAAS,6BAAT;AACA","sourcesContent":["import { Platform } from '@unimodules/core';\nimport { PermissionStatus } from 'unimodules-permissions-interface';\n\nimport ExpoLocation from './ExpoLocation';\nimport {\n  LocationAccuracy,\n  LocationCallback,\n  LocationGeocodedAddress,\n  LocationGeocodedLocation,\n  LocationHeadingCallback,\n  LocationHeadingObject,\n  LocationLastKnownOptions,\n  LocationObject,\n  LocationOptions,\n  LocationPermissionResponse,\n  LocationProviderStatus,\n  LocationRegion,\n  LocationSubscription,\n  LocationTaskOptions,\n  LocationActivityType,\n  LocationGeofencingEventType,\n  LocationGeofencingRegionState,\n  LocationGeocodingOptions,\n} from './Location.types';\nimport { LocationEventEmitter } from './LocationEventEmitter';\nimport {\n  setGoogleApiKey,\n  googleGeocodeAsync,\n  googleReverseGeocodeAsync,\n} from './LocationGoogleGeocoding';\nimport { LocationSubscriber, HeadingSubscriber, _getCurrentWatchId } from './LocationSubscribers';\n\nexport async function getProviderStatusAsync(): Promise<LocationProviderStatus> {\n  return ExpoLocation.getProviderStatusAsync();\n}\n\nexport async function enableNetworkProviderAsync(): Promise<void> {\n  // If network provider is disabled (user's location mode is set to \"Device only\"),\n  // Android's location provider may not give you any results. Use this method in order to ask the user\n  // to change the location mode to \"High accuracy\" which uses Google Play services and enables network provider.\n  // `getCurrentPositionAsync` and `watchPositionAsync` are doing it automatically anyway.\n\n  if (Platform.OS === 'android') {\n    return ExpoLocation.enableNetworkProviderAsync();\n  }\n}\n\n/**\n * Requests for one-time delivery of the user's current location.\n * Depending on given `accuracy` option it may take some time to resolve,\n * especially when you're inside a building.\n */\nexport async function getCurrentPositionAsync(\n  options: LocationOptions = {}\n): Promise<LocationObject> {\n  return ExpoLocation.getCurrentPositionAsync(options);\n}\n\n/**\n * Gets the last known position of the device or `null` if it's not available\n * or doesn't match given requirements such as maximum age or required accuracy.\n * It's considered to be faster than `getCurrentPositionAsync` as it doesn't request for the current location.\n */\nexport async function getLastKnownPositionAsync(\n  options: LocationLastKnownOptions = {}\n): Promise<LocationObject | null> {\n  return ExpoLocation.getLastKnownPositionAsync(options);\n}\n\n/**\n * Starts watching for location changes.\n * Given callback will be called once the new location is available.\n */\nexport async function watchPositionAsync(options: LocationOptions, callback: LocationCallback) {\n  const watchId = LocationSubscriber.registerCallback(callback);\n  await ExpoLocation.watchPositionImplAsync(watchId, options);\n\n  return {\n    remove() {\n      LocationSubscriber.unregisterCallback(watchId);\n    },\n  };\n}\n\n/**\n * Resolves to an object with current heading details.\n * To simplify, it calls `watchHeadingAsync` and waits for a couple of updates\n * and returns the one that is accurate enough.\n */\nexport async function getHeadingAsync(): Promise<LocationHeadingObject> {\n  return new Promise<LocationHeadingObject>(async resolve => {\n    let tries = 0;\n\n    const subscription = await watchHeadingAsync(heading => {\n      if (heading.accuracy > 1 || tries > 5) {\n        subscription.remove();\n        resolve(heading);\n      } else {\n        tries += 1;\n      }\n    });\n  });\n}\n\n/**\n * Starts watching for heading changes.\n * Given callback will be called once the new heading is available.\n */\nexport async function watchHeadingAsync(\n  callback: LocationHeadingCallback\n): Promise<LocationSubscription> {\n  const watchId = HeadingSubscriber.registerCallback(callback);\n  await ExpoLocation.watchDeviceHeading(watchId);\n\n  return {\n    remove() {\n      HeadingSubscriber.unregisterCallback(watchId);\n    },\n  };\n}\n\n/**\n * Geocodes given address to an array of latitude-longitude coordinates.\n */\nexport async function geocodeAsync(\n  address: string,\n  options?: LocationGeocodingOptions\n): Promise<LocationGeocodedLocation[]> {\n  if (typeof address !== 'string') {\n    throw new TypeError(`Address to geocode must be a string. Got ${address} instead.`);\n  }\n  if (options?.useGoogleMaps || Platform.OS === 'web') {\n    return await googleGeocodeAsync(address);\n  }\n  return await ExpoLocation.geocodeAsync(address);\n}\n\n/**\n * The opposite behavior of `geocodeAsync` — translates location coordinates to an array of addresses.\n */\nexport async function reverseGeocodeAsync(\n  location: Pick<LocationGeocodedLocation, 'latitude' | 'longitude'>,\n  options?: LocationGeocodingOptions\n): Promise<LocationGeocodedAddress[]> {\n  if (typeof location.latitude !== 'number' || typeof location.longitude !== 'number') {\n    throw new TypeError(\n      'Location to reverse-geocode must be an object with number properties `latitude` and `longitude`.'\n    );\n  }\n  if (options?.useGoogleMaps || Platform.OS === 'web') {\n    return await googleReverseGeocodeAsync(location);\n  }\n  return await ExpoLocation.reverseGeocodeAsync(location);\n}\n\n/**\n * Gets the current state of location permissions.\n */\nexport async function getPermissionsAsync(): Promise<LocationPermissionResponse> {\n  return await ExpoLocation.getPermissionsAsync();\n}\n\n/**\n * Requests the user to grant location permissions.\n */\nexport async function requestPermissionsAsync(): Promise<LocationPermissionResponse> {\n  return await ExpoLocation.requestPermissionsAsync();\n}\n\n// --- Location service\n\n/**\n * Returns `true` if the device has location services enabled or `false` otherwise.\n */\nexport async function hasServicesEnabledAsync(): Promise<boolean> {\n  return await ExpoLocation.hasServicesEnabledAsync();\n}\n\n// --- Background location updates\n\nfunction _validateTaskName(taskName: string) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new Error(`\\`taskName\\` must be a non-empty string. Got ${taskName} instead.`);\n  }\n}\n\nexport async function isBackgroundLocationAvailableAsync(): Promise<boolean> {\n  const providerStatus = await getProviderStatusAsync();\n  return providerStatus.backgroundModeEnabled;\n}\n\nexport async function startLocationUpdatesAsync(\n  taskName: string,\n  options: LocationTaskOptions = { accuracy: LocationAccuracy.Balanced }\n): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.startLocationUpdatesAsync(taskName, options);\n}\n\nexport async function stopLocationUpdatesAsync(taskName: string): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.stopLocationUpdatesAsync(taskName);\n}\n\nexport async function hasStartedLocationUpdatesAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return ExpoLocation.hasStartedLocationUpdatesAsync(taskName);\n}\n\n// --- Geofencing\n\nfunction _validateRegions(regions: LocationRegion[]) {\n  if (!regions || regions.length === 0) {\n    throw new Error(\n      'Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions'\n    );\n  }\n  for (const region of regions) {\n    if (typeof region.latitude !== 'number') {\n      throw new TypeError(`Region's latitude must be a number. Got '${region.latitude}' instead.`);\n    }\n    if (typeof region.longitude !== 'number') {\n      throw new TypeError(\n        `Region's longitude must be a number. Got '${region.longitude}' instead.`\n      );\n    }\n    if (typeof region.radius !== 'number') {\n      throw new TypeError(`Region's radius must be a number. Got '${region.radius}' instead.`);\n    }\n  }\n}\n\nexport async function startGeofencingAsync(\n  taskName: string,\n  regions: LocationRegion[] = []\n): Promise<void> {\n  _validateTaskName(taskName);\n  _validateRegions(regions);\n  await ExpoLocation.startGeofencingAsync(taskName, { regions });\n}\n\nexport async function stopGeofencingAsync(taskName: string): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.stopGeofencingAsync(taskName);\n}\n\nexport async function hasStartedGeofencingAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return ExpoLocation.hasStartedGeofencingAsync(taskName);\n}\n\n/**\n * @deprecated\n * Deprecated as of SDK39 in favour of `setGoogleApiKey`.\n */\nexport function setApiKey(apiKey: string): void {\n  console.warn(\"Location's method `setApiKey` is deprecated in favor of `setGoogleApiKey`.\");\n  setGoogleApiKey(apiKey);\n}\n\n// For internal purposes\nexport { LocationEventEmitter as EventEmitter, _getCurrentWatchId };\n\n// Export as namespaced types.\nexport {\n  LocationAccuracy as Accuracy,\n  LocationActivityType as ActivityType,\n  LocationGeofencingEventType as GeofencingEventType,\n  LocationGeofencingRegionState as GeofencingRegionState,\n  PermissionStatus,\n  setGoogleApiKey,\n};\n\nexport { installWebGeolocationPolyfill } from './GeolocationPolyfill';\nexport * from './Location.types';\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}