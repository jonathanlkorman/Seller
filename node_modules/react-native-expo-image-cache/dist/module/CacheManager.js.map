{"version":3,"sources":["CacheManager.ts"],"names":["_","FileSystem","SHA1","BASE_DIR","cacheDirectory","CacheEntry","uri","options","getCacheEntry","path","exists","tmpPath","createDownloadResumable","downloadAsync","result","status","undefined","moveAsync","from","to","CacheManager","entries","deleteAsync","idempotent","makeDirectoryAsync","getInfoAsync","Error","size","filename","substring","lastIndexOf","indexOf","length","ext","uniqueId","info"],"mappings":"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","sourcesContent":["// @flow\nimport * as _ from \"lodash\";\nimport * as FileSystem from \"expo-file-system\";\nimport SHA1 from \"crypto-js/sha1\";\n\nexport interface DownloadOptions {\n  md5?: boolean;\n  headers?: { [name: string]: string };\n}\n\nconst BASE_DIR = `${FileSystem.cacheDirectory}expo-image-cache/`;\n\nexport class CacheEntry {\n  uri: string;\n\n  options: DownloadOptions;\n\n  constructor(uri: string, options: DownloadOptions) {\n    this.uri = uri;\n    this.options = options;\n  }\n\n  async getPath(): Promise<string | undefined> {\n    const { uri, options } = this;\n    const { path, exists, tmpPath } = await getCacheEntry(uri);\n    if (exists) {\n      return path;\n    }\n    const result = await FileSystem.createDownloadResumable(uri, tmpPath, options).downloadAsync();\n    // If the image download failed, we don't cache anything\n    if (result && result.status !== 200) {\n      return undefined;\n    }\n    await FileSystem.moveAsync({ from: tmpPath, to: path });\n    return path;\n  }\n}\n\nexport default class CacheManager {\n  static entries: { [uri: string]: CacheEntry } = {};\n\n  static get(uri: string, options: DownloadOptions): CacheEntry {\n    if (!CacheManager.entries[uri]) {\n      CacheManager.entries[uri] = new CacheEntry(uri, options);\n    }\n    return CacheManager.entries[uri];\n  }\n\n  static async clearCache(): Promise<void> {\n    await FileSystem.deleteAsync(BASE_DIR, { idempotent: true });\n    await FileSystem.makeDirectoryAsync(BASE_DIR);\n  }\n\n  static async getCacheSize(): Promise<number> {\n    const result = await FileSystem.getInfoAsync(BASE_DIR);\n    if (!result.exists) {\n      throw new Error(`${BASE_DIR} not found`);\n    }\n    return result.size;\n  }\n}\n\nconst getCacheEntry = async (uri: string): Promise<{ exists: boolean; path: string; tmpPath: string }> => {\n  const filename = uri.substring(uri.lastIndexOf(\"/\"), uri.indexOf(\"?\") === -1 ? uri.length : uri.indexOf(\"?\"));\n  const ext = filename.indexOf(\".\") === -1 ? \".jpg\" : filename.substring(filename.lastIndexOf(\".\"));\n  const path = `${BASE_DIR}${SHA1(uri)}${ext}`;\n  const tmpPath = `${BASE_DIR}${SHA1(uri)}-${_.uniqueId()}${ext}`;\n  // TODO: maybe we don't have to do this every time\n  try {\n    await FileSystem.makeDirectoryAsync(BASE_DIR);\n  } catch (e) {\n    // do nothing\n  }\n  const info = await FileSystem.getInfoAsync(path);\n  const { exists } = info;\n  return { exists, path, tmpPath };\n};\n"]}